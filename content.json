[{"title":"pomelo.d.ts","date":"2018-07-16T16:28:36.000Z","path":"2018/07/17/pomelo-2/","text":"说明一下原因因为最近在使用ts开发pomelo的项目，但是目前pomelo没有带声明文件，所以在调用pomelo的api的时候会出现报错，虽然可以使用any来规避这个问题，但是总觉得不够完美所一就有了这一篇博客的由来。 因为在网上没有找到这样的东西，我决定手动去写一个pomelo.d.ts。 但是因为平时要上班，然后生活上还有一些事情，所以实际上能用来整理和写博文的时间真的是不够用，所以偷懒整合在一块来了 首先示例一下Application.js在node_modules中找到pomelo模块，然后找到模块中的application.js文件夹，同时打开[pomelo官方网站的api网页](http://pomelo.netease.com/api.html),根据王者中的api整理需要声明的函数。 先看下网站的Api中getBase函数:{% image pomelo-2/1531759043.jpg '' '' %}; 然后在代码中找到对应的api: 1234567891011121314/*** Get application base path** // cwd: /home/game/* pomelo start* // app.getBase() -&gt; /home/game** @return &#123;String&#125; application base path** @memberOf Application*/Application.getBase = function() &#123;return this.get(Constants.RESERVED.BASE);&#125;; 看看，注释是不是非常明显，方法作用：get appliaction base path, 返回： string. 所以就有了：public getBase(): string; 同理可以得出其他函数的声明。 使用VSCode的朋友，可以采用&quot;Ctrl + Shift + O&quot;快速查找方法。 下面是Application的声明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*! * Pomelo -- pomelo.d.ts * Copyright(c) 2018 Visow &lt;visow1992@gmail.com&gt; * MIT Licensed */declare class Application &#123; public getBase(): string; public filter(filter : Filter) : void; public before(bf: Filter) : void; public after(af: Filter) : void; public globalFilter(filter: Filter) : void; public globalBefore(bf: Filter) : void; public globalAfter(af: Filter) : void; public rpcBefore(bf: Filter) : void; public rpcAfter(af: Filter) : void; public rpcFilter(filter: Filter) : void; public load(name:any, compoment: any, opts: PomeloOpts): void; // 没有一个一个去找 public loadConfig(key: string, val: string) : void; public route(serverType: string, routeFunc: Function) : Application; public beforeStopHook(func: Function) : void; public start(cb: Function) : void; public set(setting: string, va: string, attach: boolean) : boolean | Application; public get&lt;T&gt;(setting: string) : T; public enabled(setting: string): boolean; public disabled(stting: string) : boolean; public enable(stting: string) : boolean | Application; public disable(stting: string) : boolean | Application; public configure(env: string, type: string, fn: Function) : Application; public registerAdmin(moduleId: string, module: any, opts: any) : void; public use(plugin: Plugin, opts: any) : void; public transaction(name: string, conditions: any, handlers: any, retry: number) : void; public getMaster() : Server; public getCurServer() : Server; public getServerId() : string | number; public getServerType() : string | number; public getServers() : Server[]; public getServersFromConfig() : Server[]; public getServerTypes() : string[]; public getServerById(serverId: string) : Server; public getServerFromConfig(serverId: string) : Server; public getServersByType(serverType: string) : Server; public isFrontend(server: Server) : boolean; public isBackend(server: Server) : boolean; public isMaster() : boolean; public addServers(servers: Server[]) : void; public removeServers(ids: string[]) : void; public replaceServers(servers: Server[]) : void public addCrons(crons: Crons[]) : void; public removeCrons(crons: Crons[]) : void;&#125; 这是目前Application部分的声明，现在还不能用，因为其中有一些类和接口还没有声明，接下去的博文会继续的。后面的博文会有引用，谢谢。","tags":[{"name":"pomelo","slug":"pomelo","permalink":"https://Visow.github.io/tags/pomelo/"}]},{"title":"Node.js npm模块的一些参数","date":"2018-07-08T13:41:07.000Z","path":"2018/07/08/nodejs-new-compoment/","text":"致歉自己这周比较忙，没有认真的写博客，但是还是抽空水一篇，也是最近掌握的一个小知识点。 Node.js项目安装模块玩过Node.js的都知道肯定是 npm install packagename; 但是对后面的参数估计有些模糊，所以做个记录： 指定版本号安装模块如不指定版本号 默认会安装最新的版本1npm install packagename 0.0.1 安装指定版本的模块 初始化Node.js项目1npm init 这个命令会在当前目录生成一个package.json文件，这个文件中会记录一些关于项目的信息，比如：项目的作者，git地址，入口文件、命令设置、项目名称和版本号等等，一般情况下这个文件是必须要有的，方便后续的项目添加和其他开发人员的使用。 保存安装模块的信息到package.json中1npm install packagename --save 或 -S –save、-S参数意思是把模块的版本信息保存到dependencies（生产环境依赖）中，即你的package.json文件的dependencies字段中；1npm install packagename --save-dev 或 -D –save-dev 、 -D参数意思是吧模块版本信息保存到devDependencies（开发环境依赖）中，即你的package.json文件的devDependencies字段中；1npm install packagename --save-optional 或 -O –save-optional 、 -O参数意思是把模块安装到optionalDependencies（可选环境依赖）中，即你的package.json文件的optionalDependencies字段中。（本人菜鸟一枚，一直也没理解这个，不过看到了就记录一下吧，万一哪天用到了，说不准就懂了……）1npm install packagename --save-exact 或 -E –save-exact 、 -E参数的意思是精确的安装指定版本的模块，细心的同学会发现dependencies字段里每个模块版本号前面的^不见鸟。。。如果你打开的是别人的项目，这个时候一般是没有任何依赖包的，但是所以需要的包已在package.json里面写好了，这个时候我们就可以使用npm install来安装所有项目中需要的依赖包了 安装到全局1npm install packagename -g 或 --global 安装全局的模块（不加参数的时候默认安装本地模块） 查看所有已经安装的模块1npm list 或 npm ll 或 npm la 或 npm ls 查看所有已经安装的模块 ll 、 ls 、 la 三个命令意思都一样 但是列表的展示方式不一样 喜欢用哪个就看个人喜好了,不懂的同学可以每个都去试下。 卸载已安装1npm uninstall packagename [options] 卸载已经安装的模块，后面的options参数意思与安装时候的意思一样,与这个命令相同的还有npm remove 、npm rm、npm r 、 npm un 、 npm unlink 这几个命令功能和npm uninstall基本一样，个人觉得没什么区别。 查看过时模块1npm outdated 这个命令会列出所有已经过时了的模块，对于已经过时了的模块可以使用下面的命令去更新 更新模块1npm update [-g] 更新已经安装的模块(或全局的模块) 帮助1npm help '命令' 查看某条命令的详细帮助 绝对路径1npm root 查看命令的绝对路径 设置代理1npm config 设置npm命令的配置路径，这个命令一般用于设置代理，毕竟大部分都是国外的模块，不过个人还是比较喜欢用cnpm 这个命令是用的淘宝的镜像，用法与npm一样，速度还可以。 除去以上的这些命令外，经常还能见到一些npm start、npm deploy、 npm build等等之类的命令，这些一般都是在package.json 中自定义的一些启动、重启、停止服务之类的命令。可以在package.json文件的scripts字段里自定义。例如：123456\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\", \"start\": \"webpack-dev-server main.js\", \"deploy\": \"set NODE_ENV=production\" &#125; 关于package.json的详细文档，有兴趣的同学可以参考《package.json中文文档》；","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://Visow.github.io/tags/Node-js/"}]},{"title":"给本博客添加评论","date":"2018-06-22T14:47:38.000Z","path":"2018/06/22/hexo-add-comment/","text":"说在前面看本博客搭建方法的请看上一篇 有点忧伤…indigo 主题原来只支持一下集中主题，具体可以参见主题配置文件：./themes/indigo/_config.yml1234567# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false 其中的友言已经gg, disqus是国外的，比较难连接，gitment只能git用户评论，所以考虑了一下，这些都不适合。后来查找资料之后发现livere是比较很是的第三方评论，所以决定就是它了。既然主题没有，那我们就自己加。加之前请准备livere(来必力)账号，地址：[https://livere.com/] 开始添加来必力注册完账号后可以获取到一段html代码，其中还有一段js代码：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=\"lv-container\" data-id=\"city\" data-uid=\"xxxxxxxxxxxxxxxxxxxxxx\"&gt;&lt;script type=\"text/javascript\"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 请记住其中的data-uid字段。以为这是我们和来必力之间的秘密。 OK，首先找到对应的位置，做对应的事情，首先我们需要一份html模板，在完成这件事件：找到文件夹：”./themes/indigo/layout/_partial/post”。然后新建一个文件： liver.ejs(EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。)在其中填入内容：123456789101112131415161718192021&lt;% if (theme.livere_uid)&#123; %&gt; &lt;section class=\"comments\" id=\"comments\"&gt; &lt;!-- 来必力City版安装代码 --&gt; &lt;div id=\"lv-container\" data-id=\"city\" data-uid=\"&lt;%- theme.livere_uid %&gt;\"&gt; &lt;script type=\"text/javascript\"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;!-- City版安装代码已完成 --&gt; &lt;/section&gt;&lt;% &#125; %&gt; 然后需要在配置文件中，加入上面代码“data-uid”中的“theme.livere_uid”字段。12345678910111213141516171819# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false##################################################################### 在这个位置加入这个字段，值为从来必力获取的uidlivere_uid: xxxxxxxxxxxxxxxxxxxxxxxxxxxxx##################################################################### gitment:# owner:# repo:# client_id:# client_secret:# Valine Comment system. https://valine.js.org 最后我们需要然我们加的代码生效：所以找到文件：”./themes/indigo/layout/_partial/post/comment.ejs”添加来必力评论组件，代码如下：12345678910111213141516&lt;% if(post.comments)&#123; %&gt;&lt;%- partial('../plugins/disqus') %&gt;&lt;%- partial('../plugins/uyan') %&gt;&lt;%- partial('../plugins/gitment') %&gt;&lt;%- partial('../plugins/valine') %&gt;// 添加来必力组件&lt;%- partial('../plugins/livere') %&gt;&lt;%- partial('../plugins/hyper-comments') %&gt;&lt;%&#125; %&gt; 大功告成，是不是很简单。往下拖的话就能看到评论的功能了。 遗憾第三方评论的加载有点慢，自己搭的话又有点麻烦，所以将就用吧。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Visow.github.io/tags/Hexo/"}]},{"title":"pomelo + vscode + typescript搭建可约束可调试的游戏服务端框架","date":"2018-06-18T14:33:12.000Z","path":"2018/06/18/pomelo-1/","text":"说在前面pomelo: 它是网易开源的一套基于Node.js的游戏服务端框架，详情请戳这里关于pomelo的种种这里不详细说。点击链接查看详情。但是由于pomelo是js项目，使用起来的时候并不是很爽，所以就有了ts的引入。 typescript: TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。换而言之，TypeScript是在JavaScript的基础上添加了语法糖，使其在使用的过程中完成了语法和类型的检测，同时达到更便利的代码提示。本质上typeScript在运行前是需要通过tsc编译成Javascript，然后运行。所以TS的最大便利是在使用的过程，而本质还是JS。对于TS的更多相关信息，自行脑补。 vscode: Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。VSC中文网,用过的都知道它的好~~~ 所以前面说了这么多，其实就是在讲，想这么干的往下看。 流程环境安装 Node.js vscode pomelo typescript 安装VSCode扩展插件：ESLint, TSLint. 新建一个Pomelo项目 新建一个文件夹 进入该文件夹 12345678910111213141516171819202122$ pomelo initThe default admin user is: username: admin password: adminYou can configure admin users by editing adminUser.json later.Please select underly connector, 1 for websocket(native socket), 2 for socket.io, 3 for wss, 4 for socket.io(wss), 5 for udp, 6 for mqtt: [1]# 选择使用的网络模式$ 1 create : E:\\pomelo\\test\\npm-install.bat create : E:\\pomelo\\test\\npm-install.sh create : E:\\pomelo\\test\\web-server create : E:\\pomelo\\test\\shared#... 省略部分输出 create : E:\\pomelo\\Test\\web-server\\public\\js\\lib\\local\\boot create : E:\\pomelo\\Test\\web-server\\public\\js\\lib\\local\\boot\\component.json create : E:\\pomelo\\Test\\web-server\\public\\js\\lib\\local\\boot\\index.js windows用户执行项目文件夹下的 “npm-install.bat”, shell 用户执行文件夹下的 “npm-install.sh” 进行依赖安装，初始化pomelo项目. 12345678910111213141516171819202122E:\\pomelo\\test&gt;npm-install.batnpm info it worked if it ends with oknpm info using npm@5.6.0npm info using node@v8.11.1#... 省略部分输出npm notice created a lockfile as package-lock.json. You should commit this file.npm info lifecycle undefined~postshrinkwrap: undefinednpm WARN Test@0.0.1 No descriptionnpm WARN Test@0.0.1 No repository field.npm WARN Test@0.0.1 No license field.#... 省略部分输出added 29 packages in 3.713snpm info lifecycle undefined~postshrinkwrap: undefinednpm WARN Test@0.0.1 No descriptionnpm WARN Test@0.0.1 No repository field.npm WARN Test@0.0.1 No license field.added 312 packages in 29.82snpm info okE:\\pomelo\\test\\game-server&gt; 至此pomelo项目创建成功。接下来测试一下项目是否正确可行。 试运行pomelo项目a. 进入到项目目录下的game-server文件夹执行app.js12345678910$ cd game-server$ node app[2018-06-20 22:05:45.215] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\application.js] application inited: \"master-server-1\"[2018-06-20 22:05:45.325] [INFO] pomelo-admin - [MqttServer] [MqttServer] listen on 3005[2018-06-20 22:05:45.328] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\master\\starter.js] Executing D:\\Program Files\\nodejs\\node.exe E:\\pomelo\\Test\\game-server\\app,env=development,id=connector-server-1,host=127.0.0.1,port=3150,clientHost=127.0.0.1,clientPort=3010,frontend=true,serverType=connector locally[2018-06-20 22:05:45.332] [INFO] pomelo-admin - [ConsoleService] try to connect master: \"master\", \"127.0.0.1\", 3005[2018-06-20 22:05:45.372] [DEBUG] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\modules\\masterwatcher.js] masterwatcher receive add server #... 省略部分输出[2018-06-20 22:05:45.715] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\master\\watchdog.js] all servers startup in 485 ms 看到 all servers startup in 485 ms 了没有，说明服务器启动成功了。 b. 有服务器肯定会有前端，前端就是项目根目录下的web-server文件夹，了解一下。进入到web-server文件夹，启动前端服务。新建一个控制台123456789101112131415$ cd web-server$ node appWarning: express.createServer() is deprecated, expressapplications no longer inherit from http.Server,please use: var express = require(\"express\"); var app = express();connect.multipart() will be removed in connect 3.0visit https://github.com/senchalabs/connect/wiki/Connect-3.0 for alternativesconnect.limit() will be removed in connect 3.0Web server has started.Please log on http://127.0.0.1:3001/index.html 其中的警告是说：’express.createServer()’ 方法已经废弃，请使用下面的‘ var express = require(“express”); var app = express();’这是因为项目的模板比较旧没有进行更新，而新版本的express已经废弃了该方法，但是目前还不影响使用，先不管它。 好了，前端也跑起来了，输入链接测试：http://127.0.0.1:3001/index.html看到下图： 表示前端启动成功了。 点击”Test Game Server”按钮，测试后端。看到下图： 表示服务端也启动成功。 如果出现启动失败请查看输出，自行百度解决，一般是由于模块没有安装完整，或者端口被占用的问题。如果又要请留言。 然后开始第二阶段，项目改造，接入TS。 改造项目为TypeScript 用VSCode打开 game-server 项目 在game-server目录下新建一个app_types文件夹。 在文件夹内添加ts配置文件“tsconfig.json”, 文件内容如下。 1234567891011&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"lib\": [ \"dom\", \"es6\", \"es2015.promise\" ], \"target\": \"es6\", \"experimentalDecorators\": true, \"skipLibCheck\": true, \"outDir\": \"../app\", \"sourceMap\": true, &#125;,&#125; 解释下ts的这个配置：“compilerOptions”: 编译选项 “module”: 指定生成哪个模块系统代码： “None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”或 “ES2015”。 “lib”: 编译过程中需要引入的库文件的列表。 可能的值为： “ ES5 “,” ES6 “,” ES2015 “,” ES7 “,” ES2016 “,” ES2017” 等； “target”: 指定ECMAScript目标版本 “ES3”（默认）， “ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”或 “ESNext”。 “experimentalDecorators”: 启用实验性的ES装饰器。(这里可以不加) “skipLibCheck”: 忽略所有的声明文件（ *.d.ts）的类型检查。 “outDir”: 重定向输出目录。 “sourceMap”：生成相应的 .map文件。 其他的配置的详情请戳这里 修改代码我们可以先看下原来app中的代码结构：–|app –|servers--|connector --|handler --entryHandler.js 这个结构是不可以乱改的，至于为啥请戳上面pomelo官网翻阅文档。 我们需要做的是，当我们写好ts的代码之后，编译之后的ts代码需要输出到app目录下，并且保证servers下的目录和pomelo的要求一直。当pomelo启动，读取服务器配置”config/server.json”时，能找到对应的js代码来启动服务。我们可以看一下server.json中的内容：123456789101112&#123; \"development\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true&#125; ] &#125;, \"production\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true&#125; ] &#125;&#125; 其中的 “connector” 表示服务型所在的目录，也就是’app/servers/connector’.所以这也是为什么需要保证app下目录的完整性。所以实际操作如下：a. 在app_types目中中创建如下文件夹结构：–|app_types –|servers –|connector –|handlerb. 在handler文件夹中新建ts文件：”entryHandler.ts”，填充如下代码1234567891011121314151617181920212223242526272829303132class ConnectorHandler &#123; protected app; constructor(app) &#123; this.app = app; &#125; public entry(msg, session, next) &#123; next(null, &#123;code: 200, msg: 'game server is ok.'&#125;); &#125; public publish(msg, session, next) &#123; var result = &#123; topic: 'publish', payload: JSON.stringify(&#123;code: 200, msg: 'publish message is ok.'&#125;) &#125;; next(null, result); &#125; public subscribe(msg, session, next) &#123; var result = &#123; topic: 'subscribe', payload: JSON.stringify(&#123;code: 200, msg: 'subscribe message is ok.'&#125;) &#125;; next(null, result); &#125;&#125;export = function(app) &#123; return new ConnectorHandler(app);&#125; c.添加ts编译任务：在VSCode下，按下快捷键Ctrl+Shift+P打开任务面板，如图所示： 选择“任务配置”（tasks: configure task）；然后选择构tsc: “构建- app_types/tsconfig.json”;这时候会在目录下创建一个.vscode文件夹，文件夹中有一个tasks.json的配置文件。task中的内容为下：1234567891011121314&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ &#123; \"type\": \"typescript\", \"tsconfig\": \"app_types\\\\tsconfig.json\", \"problemMatcher\": [ \"$tsc\" ] &#125; ]&#125; d. 配置完成之后，检测一下构建结果是否如你所示，首先删除app文件夹中所有内容；然后构建：Ctrl+Shift+B,在弹出的面板中选择构建: app_types\\tsconfig.json这是后可以看到，下方的面板中显示如下： 这时候查看下app中的文件夹，结构如下： 这时候可以发现和我们原先设想的不一样啊。。。按理说这个entryHandler.js应该在app/servers/connector/handler下才对。但是折腾了好久也没照道具体的原因和配置。但是还是有解决的方法，如果有知道的道友希望您能告知下应该这么处理，我的解决方法是：在app_types中新建一个文件夹，我叫做util,然后在util中放入一个ts脚本。然后写入一些代码。再编译(编译前请删除app中的旧的文件)。这时候如图所示： 这样就达到我们预期的效果。我们来看一下编译之后的js代码和原来的js代码的区别；12345678910111213141516171819202122232425262728// 这是编译的代码es6的版本\"use strict\";class ConnectorHandler &#123; constructor(app) &#123; this.app = app; &#125; entry(msg, session, next) &#123; next(null, &#123; code: 200, msg: 'game server is ok.' &#125;); &#125; publish(msg, session, next) &#123; var result = &#123; topic: 'publish', payload: JSON.stringify(&#123; code: 200, msg: 'publish message is ok.' &#125;) &#125;; next(null, result); &#125; subscribe(msg, session, next) &#123; var result = &#123; topic: 'subscribe', payload: JSON.stringify(&#123; code: 200, msg: 'subscribe message is ok.' &#125;) &#125;; next(null, result); &#125;&#125;module.exports = function (app) &#123; return new ConnectorHandler(app);&#125;;//# sourceMappingURL=entryHandler.js.map 12345678910111213141516171819202122232425262728// 这是原来的代码module.exports = function(app) &#123; return new Handler(app);&#125;;var Handler = function(app) &#123; this.app = app;&#125;;Handler.prototype.entry = function(msg, session, next) &#123; next(null, &#123;code: 200, msg: 'game server is ok.'&#125;);&#125;;Handler.prototype.publish = function(msg, session, next) &#123; var result = &#123; topic: 'publish', payload: JSON.stringify(&#123;code: 200, msg: 'publish message is ok.'&#125;) &#125;; next(null, result);&#125;;Handler.prototype.subscribe = function(msg, session, next) &#123; var result = &#123; topic: 'subscribe', payload: JSON.stringify(&#123;code: 200, msg: 'subscribe message is ok.'&#125;) &#125;; next(null, result);&#125;; 看起来差很多对吧，但是如果改成es5的话呢？修改tsconfig.json内容：1234567891011&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"lib\": [ \"dom\", \"es5\", \"es2015.promise\" ], \"target\": \"es5\", \"experimentalDecorators\": true, \"skipLibCheck\": true, \"outDir\": \"../app\", \"sourceMap\": true, &#125;, &#125; 然后重新编译代码，这是js脚本的内容如下：12345678910111213141516171819202122232425262728\"use strict\";var ConnectorHandler = /** @class */ (function () &#123; function ConnectorHandler(app) &#123; this.app = app; &#125; ConnectorHandler.prototype.entry = function (msg, session, next) &#123; next(null, &#123; code: 200, msg: 'game server is ok.' &#125;); &#125;; ConnectorHandler.prototype.publish = function (msg, session, next) &#123; var result = &#123; topic: 'publish', payload: JSON.stringify(&#123; code: 200, msg: 'publish message is ok.' &#125;) &#125;; next(null, result); &#125;; ConnectorHandler.prototype.subscribe = function (msg, session, next) &#123; var result = &#123; topic: 'subscribe', payload: JSON.stringify(&#123; code: 200, msg: 'subscribe message is ok.' &#125;) &#125;; next(null, result); &#125;; return ConnectorHandler;&#125;());module.exports = function (app) &#123; return new ConnectorHandler(app);&#125;;//# sourceMappingURL=entryHandler.js.map 这时候发现是不是差不多了，这是因为es6引入了类的概念，不细说，自行脑补啦，反正俩种都可以运行的。 e. 测试成果的时候到了，分别跑服务端和客户端，看看效果是不是和原来一样。 在终端输如123456789$ pomelo start# ...[2018-06-21 00:19:21.643] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\application.js] \"connector-server-1\" enter after start...[2018-06-21 00:19:21.645] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\application.js] \"connector-server-1\" finish start[2018-06-21 00:19:21.645] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\application.js] \"connector-server-1\" startup in 206 ms[2018-06-21 00:19:21.646] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\master\\watchdog.js] all servers startup in 513 ms 如果和原来一样），说明你的改造是成功的了。这是后可以尝试下启动前端，在测试一下，一般是OK的。所以接下来时调试了。 pomelo ts 版本的调试PS: 有人说，打LOG是最好的调试~~ 本教程采用远程调试的方式。 1.首先查看Node的调试参数：12345678910111213141516171819202122232425$ node -hUsage: node [options] [ -e script | script.js | - ] [arguments] node inspect script.js [arguments]Options: -v, --version print Node.js version -e, --eval script evaluate script -p, --print evaluate script and print result -c, --check syntax check script without executing -i, --interactive always enter the REPL even if stdin does not appear to be a terminal -r, --require module to preload (option can be repeated) - script read from stdin (default; interactive mode if a tty) # 这个就是我们需要的调试参数（别问我怎么知道是这个的，因为有个东西叫网络~~） --inspect[=[host:]port] activate inspector on host:port (default: 127.0.0.1:9229) --inspect-brk[=[host:]port] activate inspector on host:port and break at start of user script --inspect-port=[host:]port set host:port for inspector --no-deprecation silence deprecation warnings --trace-deprecation show stack traces on deprecations --throw-deprecation throw an exception on deprecations 找到pomelo项目中的config/server.json. 内容如下：123456789101112&#123; \"development\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true&#125; ] &#125;, \"production\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true&#125; ] &#125;&#125; 因为pomelo每一个服务器都是一个进程，所以调试的时候只能选择其中一个进行调试。虽然比较蛋疼，但是用习惯了还是好的。pomelo在启动服务器的时候会将这些参数传递给Node…应该是这样的，嗯，应该是… 修改 “connector”服务器的配置，添加调试参数：1\"args\": \" --inspect=127.0.0.1:16772\" 所以如下所示：123456789101112&#123; \"development\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true, \"args\": \" --inspect=127.0.0.1:16772\"&#125; ] &#125;, \"production\":&#123; \"connector\": [ &#123;\"id\": \"connector-server-1\", \"host\": \"127.0.0.1\", \"port\": 3150, \"clientHost\": \"127.0.0.1\", \"clientPort\": 3010, \"frontend\": true&#125; ] &#125;&#125; 这个表示我们队服务器connector开启了远程调试功能。 然后配置VSCode调试参数：如图所示： 先选择侧边栏的调试按钮，然后选择上方的配置按钮，在弹出的面板中选择Node.js, 添加launch.json 修改配置如下：12345678910111213141516171819&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", // 调试的类型 \"name\": \"pomelo remote\", // 名称 \"port\": 16772, // 监听的端口（配置在server.json中的调试端口） \"sourceMaps\": true, // 开启源映射 \"outFiles\": [ // js脚本目录 \"$&#123;workspaceRoot&#125;/app\", ], \"request\": \"attach\", // 请求配置的类型，启动或者附加，我们用的是附加 &#125; ]&#125; OK, 配置完成保存，然后开始开开心心的测试一下。 测试：a. 启动game-server123456$ pomelo start# ....Debugger listening on ws://127.0.0.1:16772/202b2f5e-3671-4fce-aca9-d2cdf175bc69For help see https://nodejs.org/en/docs/inspector# ...[2018-06-22 01:01:19.776] [INFO] pomelo - [E:\\pomelo\\Test\\game-server\\node_modules\\pomelo\\lib\\master\\watchdog.js] all servers startup in 884 ms 如果终端输出Debugger listening on ws://127.0.0.1:16772/202b2f5e-3671-4fce-aca9-d2cdf175bc69For help see https://nodejs.org/en/docs/inspector表示已经成功的启动了监听。 b. 打开前端：123456789101112131415161718Windows PowerShell版权所有 (C) Microsoft Corporation。保留所有权利。PS E:\\pomelo\\Test\\game-server&gt; cd ..PS E:\\pomelo\\Test&gt; cd .\\web-server\\PS E:\\pomelo\\Test\\web-server&gt; node appWarning: express.createServer() is deprecated, expressapplications no longer inherit from http.Server,please use: var express = require(\"express\"); var app = express();connect.multipart() will be removed in connect 3.0visit https://github.com/senchalabs/connect/wiki/Connect-3.0 for alternativesconnect.limit() will be removed in connect 3.0Web server has started.Please log on http://127.0.0.1:3001/index.html c. 按F5启动调试; 在如图的位置添加断点（app_types/servers/handler/entryHandler.ts） 启动前端：http://127.0.0.1:3001/index.html点击“Test Game Server”这时候可以看到VSCode中的断点已命中的效果： 恭喜你，说明你成功了。 注意事项如果没有命中断点，请对着教程中的步骤检查下流程，看看哪里有不一样的地方，或者下方留言问题。注意一下几个地方： tsconfig.json配置文件中的“outDir”和launch.json中的 “outFiles”中的路径请保持一致。 tsconfig.json配置中需要添加“sourceMap”，这是为了在生成时添加.map文件，以至于调试的时候能通过js查找到对应的ts代码。 launch.json配置中添加“sourceMaps”和“outFiles”将调试的js脚本定位到js的生成目录，以便于映射到对应的ts代码。 launch.json配置中的端口请和server.json配置中的端口保持一致。 gitHub:项目git：https://github.com/Visow/pomelo-game-server-demoPS: 获取完之后需要执行 “npm-install.bat”","tags":[{"name":"pomelo","slug":"pomelo","permalink":"https://Visow.github.io/tags/pomelo/"}]},{"title":"本博客搭建方法","date":"2018-06-17T17:12:25.000Z","path":"2018/06/18/2018-6-18/","text":"说在前面本博客是使用Hexo + gitHub搭建的个人博客。其中致谢于以下俩位道友：csdn z皓: 使用Hexo+github一步步搭建数以自己的博客主题提供者 yscoder:一个Material Design风格的Hexo主题。首先是Hexo+gitHub的使用安装及配置问题。由于z道友教程中内容比较详细，所以这边简单的重复一下。再次感谢道友提供的教程。然后第二部分是主题的安装。 技术准备Node.js 6.x+使用本博客需要6.x+以上版本的Node.jsNode.jsNode相关安装教程请自行百度或者谷歌，如需帮助请邮件。 GitHub通过gitHub的page来作为博客的站点，可以使用自己的服务器或者其他服务器来搭建。 流程安装Gitgit官网totroiseGit在我个人网盘 密码：wn8s，如果链接失效请告知，相关安装请自行百度或者谷歌。如需帮助请邮件。 检测Node以及git的安装情况在命令行模式下分别执行一下命令检测安装情况：1$ hexo new \"node -v\" 1$ hexo new \"npm -v\" 1$ hexo new \"git --version\" 如果没有任何报错，并且给出对应的版本号则表示安装正确。如果出现错误，请自行百度或者谷歌。如需帮助请邮件。接着就是按照z道友的教程安装Hexo环境，以及配置gitHub项目。 Hexo首先创建Blog文件夹。然后进入该文件夹，执行命令安装hexo 模块12$ cd 'your blog path'$ npm install hexo -g 检测Hexo安装情况1$ heox -v 确认hexo安装成功，在项目文件夹中初始化Hexo项目1$ heox init 成功后如图所示： 看到后面的“Start blogging with Hexo！” 表示hexo项目初始化成功。 然后是Node项目的正常流程，初始化依赖的组件：1$ npm install 首次体验Hexo123456789101112131415161718192021222324252627282930313233$ hexo gINFO Start processingINFO Files loaded in 239 msINFO Generated: index.htmlINFO Generated: archives/index.htmlINFO Generated: fancybox/blank.gifINFO Generated: fancybox/jquery.fancybox.jsINFO Generated: fancybox/jquery.fancybox.pack.jsINFO Generated: fancybox/fancybox_overlay.pngINFO Generated: fancybox/fancybox_loading@2x.gifINFO Generated: fancybox/fancybox_sprite.pngINFO Generated: fancybox/fancybox_sprite@2x.pngINFO Generated: fancybox/fancybox_loading.gifINFO Generated: fancybox/jquery.fancybox.cssINFO Generated: css/fonts/fontawesome-webfont.woffINFO Generated: js/script.jsINFO Generated: archives/2018/06/index.htmlINFO Generated: css/style.cssINFO Generated: archives/2018/index.htmlINFO Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO Generated: fancybox/helpers/jquery.fancybox-media.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO Generated: css/fonts/FontAwesome.otfINFO Generated: fancybox/helpers/fancybox_buttons.pngINFO Generated: css/fonts/fontawesome-webfont.eotINFO Generated: css/fonts/fontawesome-webfont.svgINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO Generated: css/fonts/fontawesome-webfont.ttfINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO Generated: css/images/banner.jpgINFO Generated: 2018/06/18/hello-world/index.htmlINFO 28 files generated in 521 ms 开启服务器1234$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 到此可以正式体验Hexo了。如果失败请检查是否端口被占用问题， 如果是端口被占用，可以通过如下命令修改hexo端口:1$ hexo server -p 端口号 如果步骤没有错的的，则最终效果如图所示： Github page首先呢，你需要一个GitHub账号。如果没有请跳过。。。。设置git账号：在博客根目录下运行命令行工具。推荐git自带的gitbase. 设置账号：1$git config --global user.name &quot;your git name&quot; 设置邮箱：1$git config --global user.email &quot;your git email&quot; 创建ssh:1$ ssh-keygen -t rsa -C \"your git email\" 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 添加密钥到ssh-agent1$ eval \"$(ssh-agent -s)\" 添加生成的SSH key到ssh-agent:1$ ssh-add ~/.ssh/id_rsa 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 添加完github的 ssh key后，回到项目文件夹根目录的命令行工具：123$ ssh -T git@github.comHi Visow! You've successfully authenticated, but GitHub does not provide shell access. 如果出现 Hi “you git name”则表示ssh添加成功！ 假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pair：12$ ssh-add -D$ rm -r ~/.ssh 删除你在github中的public-key 重新生成ssh密钥对1$ ssh-keygen -t rsa -C \"xxx@xxx.com\" 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 确认了ssh配置没有问题之后，到git上创建一个项目： 选择 New repository，然后可以看到创建界面 repository name的格式为 你git的用户名.github.io; ex：Visow.github.io选中 Initialize this repository with a readme;create repository!创建成功后复制项目的ssh 配置Deployment:在hexo根目录下，打开 _config.yml配置文件，修改repository(在文件尾部)：1234deploy: type: git repository: git@github.com:Visow/Visow.github.io.git // 这里是你刚才复制的ssh branch: master 修改完成后需要安装一个git的拓展组建：1$ npm install hexo-deployer-git --save 创建一篇新的博客：1$ hexo new post \"你好,Hexo\" 这时候在文件夹_posts目录下将会看到已经创建的文件 OK, 这时候可以生成部署了；1$ hexo d -g 该操作会生成对应的博客和提交代码到刚才创建的git项目中；这时候访问https://“your git name”.github.io ，将会看到生成文章了： 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来是indigo主题修改： indigo主题主题提供者 yscoder:一个Material Design风格的Hexo主题。再次感谢主题提供者 yscoder.点击上文的链接，打开主题所在的git项目；滚动页面至下方，点击文档查看：！ 安装安装很简单，在你博客的根目录，也就是Hexo的根目录下执行一下命令：1$ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 获取主题项目，安装至主题到目录下的 themes/ 进入到主题目录中, 并且获取分支12$ cd themes/indigo$ git branch 如果只存在一个分支，可以执行下面的命令获取另一分支的主题。1234# 获取远程 card 分支，并切换$ git checkout -b card origin/card# 获取远程 master 分支，并切换$ git checkout -b master origin/master 此命令只需执行一次，之后使用 git checkout [branch] 命令在两个主题之间切换。 依赖安装, 这次是在hexo（博客）的根目录：Less : 主题默认使用 less 作为 css 预处理工具。1$ npm install hexo-renderer-less --save Feed : 用于生成 rss。1$ npm install hexo-generator-feed --save Json-content: 用于生成静态站点数据，用作站内搜索的数据源。1$ npm install hexo-generator-json-content --save QRCode: 用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。1$ npm install hexo-helper-qrcode --save 至此安装完成，接下来是配置： 配置详细的配置还是看git上的文档，这边只给出一些基本的配置：开启标签页1$ hexo new page tags 修改 hexo/source/tags/index.md 的元数据: layout: tagscomments: false 开启分类页仅 card theme 支持。1$ hexo new page categories 修改 hexo/source/categories/index.md 的元数据: layout: categoriescomments: false 站点配置编辑站点配置文件，hexo/_config.yml。启用主题:1theme: indigo 基本配置12345678#为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url feed配置在hexo/_config.yml下添加如下配置：1234feed: type: atom path: atom.xml limit: 0 jsonContent配置12345678910111213141516171819#为了节约资源，可以对 jsonContent 插件生成的数据字段进行配置，减少数据文件大小。参考 hexo-generator-json-contentjsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 如下图所示： 主题配置默认配置如下:1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： 12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到 这个页面 挑选合适的图标。 rss6.x 后移除该配置项，使用站点配置中的 feed 作为统一配置。1rss: /atom.xml favicon站点 logo，显示在浏览器当前标签页左上角。1favicon: /favicon.ico 头像位于左侧菜单上方1avatar: /img/logo.jpg email头像下方1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。1color: '#3F51B5' 标签页 (old)配置标签页标题12tags: title: 标签 页面标题 (card theme)自定义归档、标签、分类页的大标题。123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 以分割摘要与文章正文。未设置时，按 excerpt_length 设置截取。1234567# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文...mathjax 开启后，使你的站点支持公式渲染，by mathjax。 请按需开启，因为此项需要加载额外的 js 文件。更具体的配置：hexo-indigo-configure至此主题安装成功。对应着修改自己需要的配置，然后发布,最终就是本博客的效果了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Visow.github.io/tags/Hexo/"}]}]